#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * 给个例子：6 6 0 6 7 3 2 2 1 7 1 3 7 6 6 6
 * 所以是看谁能替换的范围大，虽然 7 只有 3 个
 * 虽然，6 范围（第一步）为 9，而 7 也为 9，说明 7 可以一战，但这意味着 6 & 7 都可吗？
 * 不
 * 
 * 6 第一步以后变
 * 6 6 6 6 6 3 2 2 1 7 1 3 6 6 6 6 -> 占 11 格
 * 6 6 6 6 6 6 2 2 1 7 1 6 6 6 6 6
 * 6 6 6 6 6 6 6 2 1 7 6 6 6 6 6 6
 * 6 6 6 6 6 6 6 6 1 6 6 6 6 6 6 6
 * 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
 * 
 * 7 第一步后变
 * 6 6 0 7 7 7 2 2 7 7 7 7 7 7 6 6 -> 占 13 格
 * 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 6
 * 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
 * 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
 * 
 * 所以第一步占比最大的，也需要选，所以应该是：
 * 数字最多，分散度最大。什么叫分散度最大？
 * 连续（包括循环）的数字可以被压缩为一个，本例子中
 * 
 * 6 6 0 6 7 3 2 2 1 7 1 3 7 6 6 6
 * 6 0 6 7 3 2 1 7 1 3 7 6 -> 6 占 6 格，7 占 9 格，所以当然选 7
 * 
 * 总体思路：先双指针：首末，sptr == eptr 时，sptr ++，eptr --
 * 如果 sptr 发生了值变化，eptr 继续走
 * 否则继续，走到相遇（相遇就说明已经完全相等，直接返回 0）
 * eptr 停止时说明发生了值变化，此时只需要砍到值变化之前一个元素就行
 * 
 * 开始统计占比
 * 
 * 统计完占比之后，就选择占比最大的，但之后需要进行模拟吗？只需要确定连续（循环连续）的两个元素之间的最大距离
 * 次距离求除以二的ceil
 * 所以需要记录：元素的起始位置，元素的上一位置，相邻元素之间的最大差值
 * 所以空间复杂度是 O(M * 4)，key / value (M 为不相同元素的个数)
 * 其实最大差值就包含了我们需要的步数信息
 * 
 * 用哈希表即可解决。注意如果遇到了连续的元素，自动压缩空间
 * 以上思路已经够做出此题来了，由于今晚很晚了，就先不写了
 *  
 * 注意，问题体量这么大，只可能是遍历一遍就确定（不会是 n^2 的复杂度）
 * runtime: 
 * memory:  
 */
class Solution {
public:
    int minimumSeconds(vector<int>& nums) {

    }
};

int main(int argc, char** argv) {
    Solution sol;

    return 0;
}